// Function to update the cache
async function updateCache() {
  const currentTime = Date.now();
  if (currentTime - lastCacheUpdateTime < cacheDuration) {
    console.log('Cache is up to date.');
    return; // Skip updating the cache if it was updated recently
  }
  lastCacheUpdateTime = currentTime;

  try {
    // Fetch current balance of Trump's address
    const url = `https://api.etherscan.io/api?module=account&action=balance&address=${trumpAddress}&tag=latest&apikey=${etherscanApiKey}`;
    console.log(`Fetching balance from URL: ${url}`);
    const response = await axios.get(url);

    if (response.data.status !== "1") {
      console.error(`Etherscan API Error: ${response.data.message}`);
      throw new Error(`Etherscan API Error: ${response.data.message}`);
    }

    const currentTrumpBalance = response.data.result;

    if (typeof currentTrumpBalance === 'undefined') {
      throw new Error('Undefined balance received from Etherscan API');
    }

    const currentEthBalance = ethers.utils.formatEther(currentTrumpBalance);
    const provider = new ethers.providers.InfuraProvider(); // Ensure provider is defined
    const currentBlock = await provider.getBlockNumber();

    // Define block intervals
    const blocksPerDay = 6500;
    const blocksPerHour = Math.round(blocksPerDay / 24);
    const blocksPer6Hours = Math.round(blocksPerDay / 4);

    // Generate data for a specific time frame
    const generateData = async (timeFrame) => {
      let days, interval, blocksPerInterval, startDate, endDate;
      let labels = [];
      switch (timeFrame) {
        case '1d':
          days = 1;
          interval = 24;
          blocksPerInterval = blocksPerHour;
          labels = generateTimeLabels(days, interval);
          break;
        case '7d':
          days = 7;
          interval = 28;
          blocksPerInterval = blocksPer6Hours;
          labels = generateTimeLabels(days, interval);
          break;
        case '30d':
          days = 30;
          interval = 30;
          blocksPerInterval = blocksPerDay;
          labels = generateTimeLabels(days, interval);
          break;
        case 'custom':
          startDate = new Date('2024-03-20');
          endDate = new Date();
          days = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24));
          interval = 30;
          blocksPerInterval = Math.floor((blocksPerDay * days) / interval);
          labels = generateCustomTimeLabels(startDate, endDate, interval);
          break;
        default:
          throw new Error('Invalid time frame');
      }

      const ethAddedDuringTimeFrame = [];
      const ethGeneratedByDJT = [];

      // Fetch internal transactions
      const internalTransactions = await fetchInternalTransactionsEtherscan(trumpAddress);

      // Calculate cumulative ETH generated
      const cumulativeEthGenerated = calculateCumulativeEthGenerated(internalTransactions, interval);

      // Calculate ETH generated by DJT during the timeframe
      cumulativeEthGenerated.forEach((value, index) => {
        if (index > 0) {
          ethGeneratedByDJT.push(value - cumulativeEthGenerated[index - 1]);
        } else {
          ethGeneratedByDJT.push(value);
        }
      });

      // Make ETH values cumulative and adjust starting point
      const cumulativeEthAddedDuringTimeFrame = ethAddedDuringTimeFrame.reduce((acc, value, index) => {
        if (index === 0) {
          acc.push(value);
        } else {
          acc.push(acc[index - 1] + value);
        }
        return acc;
      }, []);
      const cumulativeEthGeneratedByDJT = ethGeneratedByDJT.reduce((acc, value, index) => {
        if (index === 0) {
          acc.push(0); // Start with 0
        } else {
          acc.push(acc[index - 1] + value);
        }
        return acc;
      }, []);

      return {
        labels,
        ethAddedDuringTimeFrame: cumulativeEthAddedDuringTimeFrame,
        ethGeneratedByDJT: cumulativeEthGeneratedByDJT,
        currentEthTotal: currentEthBalance,
        newEthHoldings: ethAddedDuringTimeFrame,
        newEthGeneratedDJT: cumulativeEthGeneratedByDJT
      };
    };

    // Update cache for each time frame
    cache['1d'] = await generateData('1d');
    cache['7d'] = await generateData('7d');
    cache['30d'] = await generateData('30d');
    cache['custom'] = await generateData('custom');

    console.log('Cache updated at', new Date());
  } catch (error) {
    console.error('Error updating cache:', error);
  }
}

// Initial cache update
updateCache().catch(console.error); // Catch and log any errors

// Update cache every 30 minutes
setInterval(() => {
  updateCache().catch(console.error); // Catch and log any errors
}, cacheDuration);

// API endpoint to fetch data based on time frame
app.get('/api/data', (req, res) => {
  const { timeFrame, simulate } = req.query;
  console.log(`Received request for timeFrame: ${timeFrame} with simulate: ${simulate}`);

  if (cache[timeFrame]) {
    if (simulate && simulate === 'false') {
      res.json(cache[timeFrame]);
    } else if (simulate && simulate === 'true') {
      const simulatedData = JSON.parse(JSON.stringify(cache[timeFrame])); // Deep clone the cache data
      simulatedData.cumulativeEthGenerated = simulatedData.cumulativeEthGenerated.map(value => value * 1.1); // Example simulation
      res.json(simulatedData);
    } else {
      res.json(cache[timeFrame]);
    }
  } else {
    res.status(400).json({ error: 'Invalid time frame' });
  }
});

// Fetch internal transactions from Etherscan
async function fetchInternalTransactionsEtherscan(toAddress) {
  try {
    const url = `https://api.etherscan.io/api?module=account&action=txlistinternal&address=${toAddress}&startblock=0&endblock=latest&sort=asc&apikey=${etherscanApiKey}`;
    console.log(`Fetching internal transactions from URL: ${url}`);
    const response = await axios.get(url);
    if (response.data.status === "1") {
      return response.data.result.filter(tx => tx.to.toLowerCase() === toAddress.toLowerCase());
    } else {
      console.error(`Etherscan API Error: ${response.data.message}`);
      throw new Error(`Etherscan API Error: ${response.data.message}`);
    }
  } catch (error) {
    console.error('Error fetching internal transactions from Etherscan:', error);
    return [];
  }
}

// Calculate cumulative ETH generated from transactions
function calculateCumulativeEthGenerated(transactions, interval) {
  const cumulativeEthGenerated = new Array(interval + 1).fill(0);
  transactions.forEach(tx => {
    const value = tx.value.toString();
    const integerPart = value.slice(0, -18) || '0';
    const decimalPart = value.slice(-18).padStart(18, '0');
    const ethValue = parseFloat(`${integerPart}.${decimalPart}`);
    cumulativeEthGenerated.forEach((_, index) => {
      cumulativeEthGenerated[index] += ethValue;
    });
  });
  return cumulativeEthGenerated;
}

// Generate time labels
function generateTimeLabels(days, interval) {
  const labels = [];
  const currentDate = new Date();
  for (let i = interval; i >= 0; i--) {
    const date = new Date(currentDate);
    date.setDate(currentDate.getDate() - (days / interval) * i);
    labels.push(date.toISOString().split('T')[0]);
  }
  return labels;
}

// Generate custom time labels
function generateCustomTimeLabels(startDate, endDate, interval) {
  const labels = [];
  const totalDays = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24));
  for (let i = interval; i >= 0; i--) {
    const date = new Date(startDate);
    date.setDate(startDate.getDate() + (totalDays / interval) * i);
    labels.push(date.toISOString().split('T')[0]);
  }
  return labels;
}

// Start the server
app.listen(port, () => {
  console.log(`Server running on port ${port}`);
});
